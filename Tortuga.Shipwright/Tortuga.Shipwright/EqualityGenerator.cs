using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace Tortuga.Shipwright;

/// <summary>
/// Class EqualityGenerator.
/// Implements the <see cref="Microsoft.CodeAnalysis.ISourceGenerator" />
/// </summary>
/// <seealso cref="Microsoft.CodeAnalysis.ISourceGenerator" />
[Generator]
public class EqualityGenerator : ISourceGenerator
{
    /// <summary>
    /// Called to perform source generation. A generator can use the <paramref name="context" />
    /// to add source files via the <see cref="M:Microsoft.CodeAnalysis.GeneratorExecutionContext.AddSource(System.String,Microsoft.CodeAnalysis.Text.SourceText)" />
    /// method.
    /// </summary>
    /// <param name="context">The <see cref="T:Microsoft.CodeAnalysis.GeneratorExecutionContext" /> to add source to</param>
    /// <remarks>This call represents the main generation step. It is called after a <see cref="T:Microsoft.CodeAnalysis.Compilation" /> is
    /// created that contains the user written code.
    /// A generator can use the <see cref="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.Compilation" /> property to
    /// discover information about the users compilation and make decisions on what source to
    /// provide.</remarks>
    public void Execute(GeneratorExecutionContext context)
    {
        // retrieve the populated receiver
        if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
            return;

        //Write the source code.
        foreach (var workItem in receiver.WorkItems)
        {
            var scalarProperties = workItem.ContainerClass.ReadableScalarProperties().ToList();
            if (scalarProperties.Count == 0)
            {
                receiver.Log.Add("No properties found on : " + workItem.ContainerClass.FullName());
                continue; //next class
            }
            var equatableProperties = scalarProperties.Where(x => x.HasAttribute<EqualityKeyAttribute>()).ToList();
            if (equatableProperties.Count == 0)
            {
                receiver.Log.Add("No equatable properties found on : " + workItem.ContainerClass.FullName());
                continue; //next class
            }


            try
            {
                receiver.Log.Add("Processing : " + workItem.ContainerClass.FullName());




                var fileName = workItem.ContainerClass.FullMetadataName().Replace('`', '.') + ".cs";
                var code = new CodeWriter();

                code.AppendLine("//This file was generated by Tortuga Shipwright");

                /*
                //Determine if we need a Register Traits method.

                var partialProperties = workItem.TraitClasses.SelectMany(m => m.GetMembers()).OfType<IPropertySymbol>().Where(m => m.HasAttribute<PartialAttribute>()).ToList();

                var ownerProperties = workItem.TraitClasses.SelectMany(m => m.GetMembers()).OfType<IPropertySymbol>().Where(m => m.HasAttribute<ContainerAttribute>()).ToList();

                bool useRegisterTraits = partialProperties.Any() || ownerProperties.Any();

                //receiver.Log.Add($"Working on {workItem.HostingClass.Name}");
                //receiver.Log.Add($"Found {partialProperties.Count} partial properties.");
                //receiver.Log.Add($"Found {ownerProperties.Count} owner properties.");

                //Find the list of interfaces
                var interfacesNamesA = workItem.TraitClasses.SelectMany(wi => wi.AllInterfaces);
                var interfacesNamesB = workItem.TraitClasses.SelectMany(x => x.GetMembers()).OfType<IPropertySymbol>()
                    .Where(x => (bool)(x.GetAttribute<ContainerAttribute>()?.NamedArguments.SingleOrDefault(x => x.Key == "RegisterInterface").Value.Value ?? false)).Select(x => x.Type).OfType<INamedTypeSymbol>();

                var interfacesNames = interfacesNamesA.Concat(interfacesNamesB)
                    .Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default).Select(i => i.FullName().NotNullType()).ToList();
                var interfaceString = interfacesNames.Any() ? ": " + string.Join(", ", interfacesNames) : "";

                var traitFieldNames = workItem.TraitClasses.Select((Trait, Index) => (Trait, Index))
                    .ToDictionary(item => item.Trait, item => "__Trait" + item.Index, (IEqualityComparer<INamedTypeSymbol>)SymbolEqualityComparer.Default);

                */

                code.AppendLine();
                using (code.BeginScope($"namespace {workItem.ContainerClass.FullNamespace()}"))
                {
                    using (code.BeginScope($"partial class {workItem.ContainerClass.Name}: System.IEquatable<{workItem.ContainerClass.FullName()}>"))
                    {
                        code.AppendLine();

                        //Object.Equals
                        using (code.BeginScope("public override bool Equals(object? obj)"))
                        {
                            code.AppendLine($"var other = obj as {workItem.ContainerClass.FullName()};");
                            code.AppendLine("if (other == null) return false;");
                            code.AppendLine("return Equals(other);");
                        }

                        //Object.GetHashCode
                        using (code.BeginScope("public override int GetHashCode()"))
                        {
                            code.AppendLine($"return System.HashCode.Combine({string.Join(", ", equatableProperties.Select(x => x.Name))});");
                        }


                        //IEquatable<T>.Equals
                        using (code.BeginScope($"public bool Equals({workItem.ContainerClass.FullName()}? other)"))
                        {
                            code.AppendLine("if (other == null) return false;");
                            code.AppendLine("if (ReferenceEquals(this, other)) return true;");
                            code.AppendLine();

                            foreach (var property in equatableProperties)
                            {
                                var useNullChecks = property.Type.IsReferenceType;

                                //TODO: Look for a better way to check for Nullable value types
                                if (property.Type.IsValueType && property.Type.TryFullName().StartsWith("System.Nullable<"))
                                    useNullChecks = true;

                                if (useNullChecks)
                                {
                                    using (code.BeginScope($"if ({property.Name} == null)"))
                                    {
                                        code.AppendLine($"if (other.{property.Name} != null) return false;");
                                    }
                                    code.AppendLine($"else if (!{property.Name}.Equals(other.{property.Name})) return false;");
                                }
                                else
                                {
                                    code.AppendLine($"if (!{property.Name}.Equals(other.{property.Name})) return false;");
                                }
                                code.AppendLine();
                            }




                            code.AppendLine("return true;");
                        }
                    }
                }

                context.AddSource(fileName, SourceText.From(code.ToString(), Encoding.UTF8));

            }
            catch (Exception ex)
            {
                receiver.Log.Add("Error executing generator: " + ex.ToString());
            }
        }

        //Write the log entries
        context.AddSource("Logs", SourceText.From($@"/*{Environment.NewLine + string.Join(Environment.NewLine, receiver.Log) + Environment.NewLine}*/
                        ", Encoding.UTF8));
    }

    /// <summary>
    /// Called before generation occurs. A generator can use the <paramref name="context" />
    /// to register callbacks required to perform generation.
    /// </summary>
    /// <param name="context">The <see cref="T:Microsoft.CodeAnalysis.GeneratorInitializationContext" /> to register callbacks on</param>
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a syntax receiver that will be created for each generation pass
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }








}
